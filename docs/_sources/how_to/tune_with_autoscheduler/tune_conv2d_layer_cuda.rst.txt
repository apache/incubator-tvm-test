
.. DO NOT EDIT. THIS FILE WAS AUTOMATICALLY GENERATED BY
.. TVM'S MONKEY-PATCHED VERSION OF SPHINX-GALLERY. TO MAKE
.. CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "how_to/tune_with_autoscheduler/tune_conv2d_layer_cuda.py"

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        This tutorial can be used interactively with Google Colab! You can also click
        :ref:`here <sphx_glr_download_how_to_tune_with_autoscheduler_tune_conv2d_layer_cuda.py>` to run the Jupyter notebook locally.

        .. image:: https://raw.githubusercontent.com/tlc-pack/web-data/main/images/utilities/colab_button.svg
            :align: center
            :target: https://colab.research.google.com/github/apache/tvm-site/blob/asf-site/docs/_downloads/5f1f7bd7d90710fd404f7bcdc4965622/tune_conv2d_layer_cuda.ipynb
            :width: 300px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_how_to_tune_with_autoscheduler_tune_conv2d_layer_cuda.py:


.. _auto-scheduler-conv-gpu:

Auto-scheduling a Convolution Layer for GPU
===========================================
**Author**: `Lianmin Zheng <https://github.com/merrymercy>`_,             `Chengfan Jia <https://github.com/jcf94/>`_

This is a tutorial on how to use the auto-scheduler for GPUs.

Different from the template-based :ref:`autotvm <tutorials-autotvm-sec>` which relies on
manual templates to define the search space, the auto-scheduler does not require any templates.
Users only need to write the computation declaration without any schedule commands or templates.
The auto-scheduler can automatically generate a large search space and
find a good schedule in the space.

We use a convolution layer as an example in this tutorial.

Note that this tutorial will not run on Windows or recent versions of macOS. To
get it to run, you will need to wrap the body of this tutorial in a :code:`if
__name__ == "__main__":` block.

.. GENERATED FROM PYTHON SOURCE LINES 39-47

.. code-block:: default


    import os

    import numpy as np
    import tvm
    from tvm import te, auto_scheduler, topi
    from tvm.topi.testing import conv2d_nchw_python








.. GENERATED FROM PYTHON SOURCE LINES 51-56

Define the computation
^^^^^^^^^^^^^^^^^^^^^^
To begin with, let us define the computation of a convolution layer.
The function should return the list of input/output tensors.
From these tensors, the auto-scheduler can get the whole computational graph.

.. GENERATED FROM PYTHON SOURCE LINES 56-68

.. code-block:: default



    @auto_scheduler.register_workload
    def conv2d_layer(N, H, W, CO, CI, KH, KW, stride, padding):
        data = te.placeholder((N, CI, H, W), name="data")
        kernel = te.placeholder((CO, CI, KH, KW), name="kernel")
        bias = te.placeholder((1, CO, 1, 1), name="bias")
        conv = topi.nn.conv2d_nchw(data, kernel, stride, padding, dilation=1, out_dtype="float32")
        out = topi.nn.relu(conv + bias)
        return [data, kernel, bias, out]









.. GENERATED FROM PYTHON SOURCE LINES 69-72

Create the search task
^^^^^^^^^^^^^^^^^^^^^^
We then create a search task for the last convolution layer in the resnet.

.. GENERATED FROM PYTHON SOURCE LINES 72-85

.. code-block:: default


    target = tvm.target.Target("cuda")

    # Use the last layer in ResNet-50
    N, H, W, CO, CI, KH, KW, strides, padding = 1, 7, 7, 512, 512, 3, 3, (1, 1), (1, 1)
    task = auto_scheduler.SearchTask(
        func=conv2d_layer, args=(N, H, W, CO, CI, KH, KW, strides, padding), target=target
    )

    # Inspect the computational graph
    print("Computational DAG:")
    print(task.compute_dag)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computational DAG:
    data = PLACEHOLDER [1, 512, 7, 7]
    pad_temp(i0, i1, i2, i3) = tir.if_then_else(((((i2 >= 1) && (i2 < 8)) && (i3 >= 1)) && (i3 < 8)), data[i0, i1, (i2 - 1), (i3 - 1)], 0f)
    kernel = PLACEHOLDER [512, 512, 3, 3]
    conv2d_nchw(nn, ff, yy, xx) += (pad_temp[nn, rc, (yy + ry), (xx + rx)]*kernel[ff, rc, ry, rx])
    bias = PLACEHOLDER [1, 512, 1, 1]
    T_add(ax0, ax1, ax2, ax3) = (conv2d_nchw[ax0, ax1, ax2, ax3] + bias[ax0, ax1, 0, 0])
    compute(i0, i1, i2, i3) = max(T_add[i0, i1, i2, i3], 0f)





.. GENERATED FROM PYTHON SOURCE LINES 86-103

Next, we set parameters for the auto-scheduler. These parameters
mainly specify how we do the measurement during the search.

* :code:`measure_ctx` launches a different process for measurement to
  provide isolation. It can protect the main process from GPU crashes
  during measurement and avoid other runtime conflicts.
* :code:`min_repeat_ms` defines the minimum duration of one "repeat" in every measurement.
  This can warmup the GPU, which is necessary to get accurate measurement results.
  Typically, we recommend a value >= 300 ms.
* :code:`num_measure_trials` is the number of measurement trials we can use during the search.
  We only make 10 trials in this tutorial for a fast demonstration. In practice, 1000 is a
  good value for the search to converge. You can do more trials according to your time budget.
* In addition, we use :code:`RecordToFile` to dump measurement records into a file `conv2d.json`.
  The measurement records can be used to query the history best, resume the search,
  and do more analyses later.
* see :any:`auto_scheduler.TuningOptions`,
  :any:`auto_scheduler.LocalRPCMeasureContext` for more parameters.

.. GENERATED FROM PYTHON SOURCE LINES 103-113

.. code-block:: default


    log_file = "conv2d.json"
    measure_ctx = auto_scheduler.LocalRPCMeasureContext(min_repeat_ms=300)
    tune_option = auto_scheduler.TuningOptions(
        num_measure_trials=10,  # change this to 1000 to achieve the best performance
        runner=measure_ctx.runner,
        measure_callbacks=[auto_scheduler.RecordToFile(log_file)],
        verbose=2,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Get devices for measurement successfully!




.. GENERATED FROM PYTHON SOURCE LINES 114-120

Run the search
^^^^^^^^^^^^^^
Now we get all inputs ready. Pretty simple, isn't it?
We can kick off the search and let the auto-scheduler do its magic.
After some measurement trials, we can load the best schedule from the log
file and apply it.

.. GENERATED FROM PYTHON SOURCE LINES 120-129

.. code-block:: default


    # Run auto-tuning (search)
    task.tune(tune_option)
    # Apply the best schedule
    sch, args = task.apply_best(log_file)

    # Kill the measurement process
    del measure_ctx








.. GENERATED FROM PYTHON SOURCE LINES 130-133

We can lower the schedule to see the IR after auto-scheduling.
The auto-scheduler correctly performs optimizations including multi-level tiling,
cooperative fetching, unrolling and operator fusion.

.. GENERATED FROM PYTHON SOURCE LINES 133-137

.. code-block:: default


    print("Lowered TIR:")
    print(tvm.lower(sch, args, simple_mode=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Lowered TIR:
    # from tvm.script import ir as I
    # from tvm.script import tir as T

    @I.ir_module
    class Module:
        @T.prim_func
        def main(data: T.Buffer((1, 512, 7, 7), "float32"), kernel: T.Buffer((512, 512, 3, 3), "float32"), bias: T.Buffer((1, 512, 1, 1), "float32"), compute: T.Buffer((1, 512, 7, 7), "float32")):
            T.func_attr({"from_legacy_te_schedule": T.bool(True), "global_symbol": "main", "tir.noalias": T.bool(True)})
            blockIdx_x = T.launch_thread("blockIdx.x", 32)
            conv2d_nchw = T.allocate([7], "float32", "local")
            pad_temp_shared = T.allocate([648], "float32", "shared")
            kernel_shared = T.allocate([1152], "float32", "shared")
            threadIdx_x = T.launch_thread("threadIdx.x", 112)
            conv2d_nchw_1 = T.Buffer((1,), data=conv2d_nchw, scope="local", align=4)
            conv2d_nchw_1[0] = T.float32(0)
            conv2d_nchw_1[1] = T.float32(0)
            conv2d_nchw_1[2] = T.float32(0)
            conv2d_nchw_1[3] = T.float32(0)
            conv2d_nchw_1[4] = T.float32(0)
            conv2d_nchw_1[5] = T.float32(0)
            conv2d_nchw_1[6] = T.float32(0)
            for rc_outer_outer in range(64):
                pad_temp_shared_1 = T.Buffer((648,), data=pad_temp_shared, scope="shared")
                for ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer in range(6):
                    threadIdx_x_1 = T.launch_thread("threadIdx.x", 112)
                    if T.likely(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 14 + threadIdx_x_1 // 8 < 81):
                        data_1 = T.Buffer((25088,), data=data.data)
                        pad_temp_shared_1[ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 112 + threadIdx_x_1] = T.if_then_else(9 <= (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31 + threadIdx_x_1) % 81 and (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31 + threadIdx_x_1) % 81 < 72 and 1 <= (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4 + threadIdx_x_1) % 9 and (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4 + threadIdx_x_1) % 9 < 8, data_1[rc_outer_outer * 392 + (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 112 + threadIdx_x_1) // 81 * 49 + (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31 + threadIdx_x_1) % 81 // 9 * 7 + (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4 + threadIdx_x_1) % 9 - 8], T.float32(0))
                kernel_shared_1 = T.Buffer((1152,), data=kernel_shared, scope="shared")
                for ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer in range(2):
                    threadIdx_x_1 = T.launch_thread("threadIdx.x", 112)
                    for ax0_ax1_fused_ax2_fused_ax3_fused_inner_s in range(6):
                        if T.likely(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 7 + threadIdx_x_1 // 16 < 12):
                            kernel_1 = T.Buffer((2359296,), data=kernel.data)
                            kernel_shared_1[ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 672 + threadIdx_x_1 * 6 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_s] = kernel_1[blockIdx_x * 73728 + (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 28 + threadIdx_x_1 // 4) // 3 * 4608 + rc_outer_outer * 72 + (ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 224 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_s // 3) % 24 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_s % 3]
                for rc_outer_inner, ry_outer_inner, rx_outer_inner, rc_inner in T.grid(2, 3, 3, 4):
                    conv2d_nchw_1[0] = conv2d_nchw_1[0] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[1] = conv2d_nchw_1[1] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 1] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[2] = conv2d_nchw_1[2] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 2] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[3] = conv2d_nchw_1[3] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 3] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[4] = conv2d_nchw_1[4] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 4] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[5] = conv2d_nchw_1[5] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 5] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
                    conv2d_nchw_1[6] = conv2d_nchw_1[6] + pad_temp_shared_1[rc_outer_inner * 324 + rc_inner * 81 + ry_outer_inner * 9 + threadIdx_x % 7 * 9 + rx_outer_inner + 6] * kernel_shared_1[threadIdx_x // 7 * 72 + rc_outer_inner * 36 + rc_inner * 9 + ry_outer_inner * 3 + rx_outer_inner]
            compute_1 = T.Buffer((25088,), data=compute.data)
            bias_1 = T.Buffer((512,), data=bias.data)
            compute_1[blockIdx_x * 784 + threadIdx_x * 7] = T.max(conv2d_nchw_1[0] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 1] = T.max(conv2d_nchw_1[1] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 2] = T.max(conv2d_nchw_1[2] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 3] = T.max(conv2d_nchw_1[3] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 4] = T.max(conv2d_nchw_1[4] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 5] = T.max(conv2d_nchw_1[5] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))
            compute_1[blockIdx_x * 784 + threadIdx_x * 7 + 6] = T.max(conv2d_nchw_1[6] + bias_1[blockIdx_x * 16 + threadIdx_x // 7], T.float32(0))




.. GENERATED FROM PYTHON SOURCE LINES 138-141

Check correctness and evaluate performance
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We build the binary and check its correctness and performance.

.. GENERATED FROM PYTHON SOURCE LINES 141-168

.. code-block:: default


    func = tvm.build(sch, args, target)

    # Check correctness
    data_np = np.random.uniform(size=(N, CI, H, W)).astype(np.float32)
    weight_np = np.random.uniform(size=(CO, CI, KH, KW)).astype(np.float32)
    bias_np = np.random.uniform(size=(1, CO, 1, 1)).astype(np.float32)
    conv_np = conv2d_nchw_python(data_np, weight_np, strides, padding)
    out_np = np.maximum(conv_np + bias_np, 0.0)

    dev = tvm.cuda()
    data_tvm = tvm.nd.array(data_np, device=dev)
    weight_tvm = tvm.nd.array(weight_np, device=dev)
    bias_tvm = tvm.nd.array(bias_np, device=dev)
    out_tvm = tvm.nd.empty(out_np.shape, device=dev)
    func(data_tvm, weight_tvm, bias_tvm, out_tvm)

    # Check results
    np.testing.assert_allclose(out_np, out_tvm.numpy(), rtol=1e-3)

    # Evaluate execution time
    evaluator = func.time_evaluator(func.entry_name, dev, min_repeat_ms=500)
    print(
        "Execution time of this operator: %.3f ms"
        % (np.median(evaluator(data_tvm, weight_tvm, bias_tvm, out_tvm).results) * 1000)
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Execution time of this operator: 0.295 ms




.. GENERATED FROM PYTHON SOURCE LINES 169-174

Using the record file
^^^^^^^^^^^^^^^^^^^^^
During the search, all measurement records are dumped into the record
file "conv2d.json". The measurement records can be used to re-apply search results,
resume the search, and perform other analyses.

.. GENERATED FROM PYTHON SOURCE LINES 176-179

Here is an example where we load the best schedule from a file,
print the equivalent python schedule API and CUDA source code.
They can be used for debugging and learning the behavior of the auto-scheduler.

.. GENERATED FROM PYTHON SOURCE LINES 179-186

.. code-block:: default


    print("Equivalent python schedule:")
    print(task.print_best(log_file, print_mode="schedule"))

    print("CUDA source code:")
    print(task.print_best(log_file, print_mode="cuda"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Equivalent python schedule:
    pad_temp_i0, pad_temp_i1, pad_temp_i2, pad_temp_i3 = tuple(pad_temp.op.axis) + tuple(pad_temp.op.reduce_axis)
    conv2d_nchw_nn, conv2d_nchw_ff, conv2d_nchw_yy, conv2d_nchw_xx, conv2d_nchw_rc, conv2d_nchw_ry, conv2d_nchw_rx = tuple(conv2d_nchw.op.axis) + tuple(conv2d_nchw.op.reduce_axis)
    T_add_ax0, T_add_ax1, T_add_ax2, T_add_ax3 = tuple(T_add.op.axis) + tuple(T_add.op.reduce_axis)
    compute_i0, compute_i1, compute_i2, compute_i3 = tuple(compute.op.axis) + tuple(compute.op.reduce_axis)
    s[T_add].compute_inline()
    conv2d_nchw_nn_o_i, conv2d_nchw_nn_i = s[conv2d_nchw].split(conv2d_nchw_nn, factor=1)
    conv2d_nchw_nn_o_o_i, conv2d_nchw_nn_o_i = s[conv2d_nchw].split(conv2d_nchw_nn_o_i, factor=1)
    conv2d_nchw_nn_o_o_o_i, conv2d_nchw_nn_o_o_i = s[conv2d_nchw].split(conv2d_nchw_nn_o_o_i, factor=1)
    conv2d_nchw_nn_o_o_o_o, conv2d_nchw_nn_o_o_o_i = s[conv2d_nchw].split(conv2d_nchw_nn_o_o_o_i, factor=1)
    conv2d_nchw_ff_o_i, conv2d_nchw_ff_i = s[conv2d_nchw].split(conv2d_nchw_ff, factor=1)
    conv2d_nchw_ff_o_o_i, conv2d_nchw_ff_o_i = s[conv2d_nchw].split(conv2d_nchw_ff_o_i, factor=1)
    conv2d_nchw_ff_o_o_o_i, conv2d_nchw_ff_o_o_i = s[conv2d_nchw].split(conv2d_nchw_ff_o_o_i, factor=16)
    conv2d_nchw_ff_o_o_o_o, conv2d_nchw_ff_o_o_o_i = s[conv2d_nchw].split(conv2d_nchw_ff_o_o_o_i, factor=1)
    conv2d_nchw_yy_o_i, conv2d_nchw_yy_i = s[conv2d_nchw].split(conv2d_nchw_yy, factor=1)
    conv2d_nchw_yy_o_o_i, conv2d_nchw_yy_o_i = s[conv2d_nchw].split(conv2d_nchw_yy_o_i, factor=1)
    conv2d_nchw_yy_o_o_o_i, conv2d_nchw_yy_o_o_i = s[conv2d_nchw].split(conv2d_nchw_yy_o_o_i, factor=7)
    conv2d_nchw_yy_o_o_o_o, conv2d_nchw_yy_o_o_o_i = s[conv2d_nchw].split(conv2d_nchw_yy_o_o_o_i, factor=1)
    conv2d_nchw_xx_o_i, conv2d_nchw_xx_i = s[conv2d_nchw].split(conv2d_nchw_xx, factor=1)
    conv2d_nchw_xx_o_o_i, conv2d_nchw_xx_o_i = s[conv2d_nchw].split(conv2d_nchw_xx_o_i, factor=1)
    conv2d_nchw_xx_o_o_o_i, conv2d_nchw_xx_o_o_i = s[conv2d_nchw].split(conv2d_nchw_xx_o_o_i, factor=1)
    conv2d_nchw_xx_o_o_o_o, conv2d_nchw_xx_o_o_o_i = s[conv2d_nchw].split(conv2d_nchw_xx_o_o_o_i, factor=7)
    conv2d_nchw_rc_o_i, conv2d_nchw_rc_i = s[conv2d_nchw].split(conv2d_nchw_rc, factor=4)
    conv2d_nchw_rc_o_o, conv2d_nchw_rc_o_i = s[conv2d_nchw].split(conv2d_nchw_rc_o_i, factor=2)
    conv2d_nchw_ry_o_i, conv2d_nchw_ry_i = s[conv2d_nchw].split(conv2d_nchw_ry, factor=1)
    conv2d_nchw_ry_o_o, conv2d_nchw_ry_o_i = s[conv2d_nchw].split(conv2d_nchw_ry_o_i, factor=3)
    conv2d_nchw_rx_o_i, conv2d_nchw_rx_i = s[conv2d_nchw].split(conv2d_nchw_rx, factor=1)
    conv2d_nchw_rx_o_o, conv2d_nchw_rx_o_i = s[conv2d_nchw].split(conv2d_nchw_rx_o_i, factor=3)
    s[conv2d_nchw].reorder(conv2d_nchw_nn_o_o_o_o, conv2d_nchw_ff_o_o_o_o, conv2d_nchw_yy_o_o_o_o, conv2d_nchw_xx_o_o_o_o, conv2d_nchw_nn_o_o_o_i, conv2d_nchw_ff_o_o_o_i, conv2d_nchw_yy_o_o_o_i, conv2d_nchw_xx_o_o_o_i, conv2d_nchw_nn_o_o_i, conv2d_nchw_ff_o_o_i, conv2d_nchw_yy_o_o_i, conv2d_nchw_xx_o_o_i, conv2d_nchw_rc_o_o, conv2d_nchw_ry_o_o, conv2d_nchw_rx_o_o, conv2d_nchw_rc_o_i, conv2d_nchw_ry_o_i, conv2d_nchw_rx_o_i, conv2d_nchw_nn_o_i, conv2d_nchw_ff_o_i, conv2d_nchw_yy_o_i, conv2d_nchw_xx_o_i, conv2d_nchw_rc_i, conv2d_nchw_ry_i, conv2d_nchw_rx_i, conv2d_nchw_nn_i, conv2d_nchw_ff_i, conv2d_nchw_yy_i, conv2d_nchw_xx_i)
    compute_i0_o_i, compute_i0_i = s[compute].split(compute_i0, factor=1)
    compute_i0_o_o_i, compute_i0_o_i = s[compute].split(compute_i0_o_i, factor=1)
    compute_i0_o_o_o, compute_i0_o_o_i = s[compute].split(compute_i0_o_o_i, factor=1)
    compute_i1_o_i, compute_i1_i = s[compute].split(compute_i1, factor=1)
    compute_i1_o_o_i, compute_i1_o_i = s[compute].split(compute_i1_o_i, factor=16)
    compute_i1_o_o_o, compute_i1_o_o_i = s[compute].split(compute_i1_o_o_i, factor=1)
    compute_i2_o_i, compute_i2_i = s[compute].split(compute_i2, factor=1)
    compute_i2_o_o_i, compute_i2_o_i = s[compute].split(compute_i2_o_i, factor=7)
    compute_i2_o_o_o, compute_i2_o_o_i = s[compute].split(compute_i2_o_o_i, factor=1)
    compute_i3_o_i, compute_i3_i = s[compute].split(compute_i3, factor=1)
    compute_i3_o_o_i, compute_i3_o_i = s[compute].split(compute_i3_o_i, factor=1)
    compute_i3_o_o_o, compute_i3_o_o_i = s[compute].split(compute_i3_o_o_i, factor=7)
    s[compute].reorder(compute_i0_o_o_o, compute_i1_o_o_o, compute_i2_o_o_o, compute_i3_o_o_o, compute_i0_o_o_i, compute_i1_o_o_i, compute_i2_o_o_i, compute_i3_o_o_i, compute_i0_o_i, compute_i1_o_i, compute_i2_o_i, compute_i3_o_i, compute_i0_i, compute_i1_i, compute_i2_i, compute_i3_i)
    s[conv2d_nchw].compute_at(s[compute], compute_i3_o_i)
    kernel_shared = s.cache_read(kernel, "shared", [conv2d_nchw])
    kernel_shared_ax0, kernel_shared_ax1, kernel_shared_ax2, kernel_shared_ax3 = tuple(kernel_shared.op.axis)
    s[kernel_shared].compute_at(s[conv2d_nchw], conv2d_nchw_rx_o_o)
    pad_temp_shared = s.cache_read(pad_temp, "shared", [conv2d_nchw])
    pad_temp_shared_ax0, pad_temp_shared_ax1, pad_temp_shared_ax2, pad_temp_shared_ax3 = tuple(pad_temp_shared.op.axis)
    s[pad_temp_shared].compute_at(s[conv2d_nchw], conv2d_nchw_rx_o_o)
    s[pad_temp].compute_inline()
    compute_i0_o_o_o_i1_o_o_o_fused_i2_o_o_o_fused_i3_o_o_o_fused = s[compute].fuse(compute_i0_o_o_o, compute_i1_o_o_o, compute_i2_o_o_o, compute_i3_o_o_o)
    s[compute].bind(compute_i0_o_o_o_i1_o_o_o_fused_i2_o_o_o_fused_i3_o_o_o_fused, te.thread_axis("blockIdx.x"))
    compute_i0_o_o_i_i1_o_o_i_fused_i2_o_o_i_fused_i3_o_o_i_fused = s[compute].fuse(compute_i0_o_o_i, compute_i1_o_o_i, compute_i2_o_o_i, compute_i3_o_o_i)
    s[compute].bind(compute_i0_o_o_i_i1_o_o_i_fused_i2_o_o_i_fused_i3_o_o_i_fused, te.thread_axis("vthread"))
    compute_i0_o_i_i1_o_i_fused_i2_o_i_fused_i3_o_i_fused = s[compute].fuse(compute_i0_o_i, compute_i1_o_i, compute_i2_o_i, compute_i3_o_i)
    s[compute].bind(compute_i0_o_i_i1_o_i_fused_i2_o_i_fused_i3_o_i_fused, te.thread_axis("threadIdx.x"))
    kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused = s[kernel_shared].fuse(kernel_shared_ax0, kernel_shared_ax1, kernel_shared_ax2, kernel_shared_ax3)
    kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o, kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_i = s[kernel_shared].split(kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused, factor=6)
    s[kernel_shared].vectorize(kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_i)
    kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_o, kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_i = s[kernel_shared].split(kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o, factor=112)
    s[kernel_shared].bind(kernel_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_i, te.thread_axis("threadIdx.x"))
    pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused = s[pad_temp_shared].fuse(pad_temp_shared_ax0, pad_temp_shared_ax1, pad_temp_shared_ax2, pad_temp_shared_ax3)
    pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o, pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_i = s[pad_temp_shared].split(pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused, factor=1)
    s[pad_temp_shared].vectorize(pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_i)
    pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_o, pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_i = s[pad_temp_shared].split(pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o, factor=112)
    s[pad_temp_shared].bind(pad_temp_shared_ax0_ax1_fused_ax2_fused_ax3_fused_o_i, te.thread_axis("threadIdx.x"))
    s[conv2d_nchw].pragma(conv2d_nchw_nn_o_o_o_o, "auto_unroll_max_step", 0)
    s[conv2d_nchw].pragma(conv2d_nchw_nn_o_o_o_o, "unroll_explicit", True)

    CUDA source code:

    #if (((__CUDACC_VER_MAJOR__ == 11) && (__CUDACC_VER_MINOR__ >= 4)) || \
         (__CUDACC_VER_MAJOR__ > 11))
    #define TVM_ENABLE_L2_PREFETCH 1
    #else
    #define TVM_ENABLE_L2_PREFETCH 0
    #endif

    #ifdef _WIN32
      using uint = unsigned int;
      using uchar = unsigned char;
      using ushort = unsigned short;
      using int64_t = long long;
      using uint64_t = unsigned long long;
    #else
      #define uint unsigned int
      #define uchar unsigned char
      #define ushort unsigned short
      #define int64_t long long
      #define uint64_t unsigned long long
    #endif
    extern "C" __global__ void __launch_bounds__(112) default_function_kernel0(float* __restrict__ data, float* __restrict__ kernel, float* __restrict__ compute, float* __restrict__ bias) {
      float conv2d_nchw[7];
      __shared__ float pad_temp_shared[648];
      __shared__ float kernel_shared[1152];
      conv2d_nchw[0] = 0.000000e+00f;
      conv2d_nchw[1] = 0.000000e+00f;
      conv2d_nchw[2] = 0.000000e+00f;
      conv2d_nchw[3] = 0.000000e+00f;
      conv2d_nchw[4] = 0.000000e+00f;
      conv2d_nchw[5] = 0.000000e+00f;
      conv2d_nchw[6] = 0.000000e+00f;
      for (int rc_outer_outer = 0; rc_outer_outer < 64; ++rc_outer_outer) {
        __syncthreads();
        for (int ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer = 0; ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer < 6; ++ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer) {
          if (((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 14) + (((int)threadIdx.x) >> 3)) < 81) {
            pad_temp_shared[((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 112) + ((int)threadIdx.x))] = (((((9 <= (((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31) + ((int)threadIdx.x)) % 81)) && ((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31) + ((int)threadIdx.x)) % 81) < 72)) && (1 <= (((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4) + ((int)threadIdx.x)) % 9))) && ((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4) + ((int)threadIdx.x)) % 9) < 8)) ? data[(((((rc_outer_outer * 392) + ((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 112) + ((int)threadIdx.x)) / 81) * 49)) + (((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 31) + ((int)threadIdx.x)) % 81) / 9) * 7)) + (((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer * 4) + ((int)threadIdx.x)) % 9)) - 8)] : 0.000000e+00f);
          }
        }
        for (int ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 = 0; ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 < 2; ++ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1) {
          for (int ax0_ax1_fused_ax2_fused_ax3_fused_inner_s = 0; ax0_ax1_fused_ax2_fused_ax3_fused_inner_s < 6; ++ax0_ax1_fused_ax2_fused_ax3_fused_inner_s) {
            if (((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 * 7) + (((int)threadIdx.x) >> 4)) < 12) {
              kernel_shared[(((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 * 672) + (((int)threadIdx.x) * 6)) + ax0_ax1_fused_ax2_fused_ax3_fused_inner_s)] = kernel[(((((((int)blockIdx.x) * 73728) + ((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 * 28) + (((int)threadIdx.x) >> 2)) / 3) * 4608)) + (rc_outer_outer * 72)) + (((((ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_1 * 224) + (((int)threadIdx.x) * 2)) + (ax0_ax1_fused_ax2_fused_ax3_fused_inner_s / 3)) % 24) * 3)) + (ax0_ax1_fused_ax2_fused_ax3_fused_inner_s % 3))];
            }
          }
        }
        __syncthreads();
        for (int rc_outer_inner = 0; rc_outer_inner < 2; ++rc_outer_inner) {
          for (int ry_outer_inner = 0; ry_outer_inner < 3; ++ry_outer_inner) {
            for (int rx_outer_inner = 0; rx_outer_inner < 3; ++rx_outer_inner) {
              for (int rc_inner = 0; rc_inner < 4; ++rc_inner) {
                conv2d_nchw[0] = (conv2d_nchw[0] + (pad_temp_shared[(((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[1] = (conv2d_nchw[1] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 1)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[2] = (conv2d_nchw[2] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 2)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[3] = (conv2d_nchw[3] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 3)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[4] = (conv2d_nchw[4] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 4)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[5] = (conv2d_nchw[5] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 5)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
                conv2d_nchw[6] = (conv2d_nchw[6] + (pad_temp_shared[((((((rc_outer_inner * 324) + (rc_inner * 81)) + (ry_outer_inner * 9)) + ((((int)threadIdx.x) % 7) * 9)) + rx_outer_inner) + 6)] * kernel_shared[((((((((int)threadIdx.x) / 7) * 72) + (rc_outer_inner * 36)) + (rc_inner * 9)) + (ry_outer_inner * 3)) + rx_outer_inner)]));
              }
            }
          }
        }
      }
      compute[((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7))] = max((conv2d_nchw[0] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 1)] = max((conv2d_nchw[1] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 2)] = max((conv2d_nchw[2] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 3)] = max((conv2d_nchw[3] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 4)] = max((conv2d_nchw[4] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 5)] = max((conv2d_nchw[5] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
      compute[(((((int)blockIdx.x) * 784) + (((int)threadIdx.x) * 7)) + 6)] = max((conv2d_nchw[6] + bias[((((int)blockIdx.x) * 16) + (((int)threadIdx.x) / 7))]), 0.000000e+00f);
    }






.. GENERATED FROM PYTHON SOURCE LINES 187-191

A more complicated example is to resume the search.
In this case, we need to create the search policy and cost model by ourselves
and resume the status of search policy and cost model with the log file.
In the example below we resume the status and do more 5 trials.

.. GENERATED FROM PYTHON SOURCE LINES 191-213

.. code-block:: default



    def resume_search(task, log_file):
        print("Resume search:")
        cost_model = auto_scheduler.XGBModel()
        cost_model.update_from_file(log_file)
        search_policy = auto_scheduler.SketchPolicy(
            task, cost_model, init_search_callbacks=[auto_scheduler.PreloadMeasuredStates(log_file)]
        )
        measure_ctx = auto_scheduler.LocalRPCMeasureContext(min_repeat_ms=300)
        tune_option = auto_scheduler.TuningOptions(
            num_measure_trials=5,
            runner=measure_ctx.runner,
            measure_callbacks=[auto_scheduler.RecordToFile(log_file)],
        )
        task.tune(tune_option, search_policy=search_policy)

        # Kill the measurement process
        del measure_ctx


    resume_search(task, log_file)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Resume search:
    Get devices for measurement successfully!






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 6 minutes  9.986 seconds)


.. _sphx_glr_download_how_to_tune_with_autoscheduler_tune_conv2d_layer_cuda.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tune_conv2d_layer_cuda.py <tune_conv2d_layer_cuda.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tune_conv2d_layer_cuda.ipynb <tune_conv2d_layer_cuda.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
